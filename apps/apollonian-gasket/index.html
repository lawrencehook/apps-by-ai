<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Apollonian Gasket - Apps by AI</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            font-family: system-ui, -apple-system, sans-serif;
            background: #0a0a0f;
            height: 100vh;
            overflow: hidden;
            color: #e0e0e0;
        }
        .container {
            height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 12px;
        }
        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        .title-section {
            display: flex;
            align-items: baseline;
            gap: 12px;
        }
        h1 { font-size: 1.3rem; color: #fff; }
        .subtitle { color: #666; font-size: 0.8rem; }
        .back-link {
            color: #666; text-decoration: none; font-size: 13px;
            padding: 6px 12px; background: rgba(255,255,255,0.05);
            border-radius: 6px; border: 1px solid rgba(255,255,255,0.1);
        }
        .back-link:hover { color: #fff; }
        .controls {
            display: flex;
            gap: 16px;
            align-items: center;
            padding: 10px 14px;
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 8px;
            margin-bottom: 10px;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        label { color: #888; font-size: 0.75rem; }
        input[type="range"] { width: 100px; accent-color: #4ecdc4; }
        .value { color: #4ecdc4; font-family: monospace; font-size: 0.8rem; min-width: 30px; }
        select, button {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.15);
            color: #fff; padding: 5px 12px; border-radius: 4px; font-size: 0.8rem;
            cursor: pointer;
        }
        button:hover { background: rgba(255,255,255,0.1); }
        .btn-primary {
            background: rgba(78, 205, 196, 0.15);
            border-color: rgba(78, 205, 196, 0.3);
            color: #4ecdc4;
        }
        .canvas-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 0;
        }
        canvas {
            max-width: 100%;
            max-height: 100%;
            border-radius: 8px;
        }
        .info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.75rem;
            color: #888;
        }
        .info span { color: #4ecdc4; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="title-section">
                <h1>Apollonian Gasket</h1>
                <span class="subtitle">Recursive circle packing fractal</span>
            </div>
            <a href="../../index.html" class="back-link">← Back</a>
        </div>

        <div class="controls">
            <div class="control-group">
                <label>Depth</label>
                <input type="range" id="depth" min="3" max="9" value="7">
                <span class="value" id="depthVal">7</span>
            </div>
            <div class="control-group">
                <label>Style</label>
                <select id="style">
                    <option value="filled">Filled</option>
                    <option value="outline">Outline</option>
                    <option value="gradient">Gradient</option>
                </select>
            </div>
            <div class="control-group">
                <label>Colors</label>
                <select id="colorScheme">
                    <option value="rainbow">Rainbow</option>
                    <option value="cool">Cool</option>
                    <option value="warm">Warm</option>
                    <option value="mono">Monochrome</option>
                </select>
            </div>
            <button class="btn-primary" id="regenerate">Regenerate</button>
        </div>

        <div class="canvas-container">
            <canvas id="canvas"></canvas>
            <div class="info">Circles: <span id="circleCount">0</span></div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const depthSlider = document.getElementById('depth');
        const styleSelect = document.getElementById('style');
        const colorSelect = document.getElementById('colorScheme');

        let circles = [];
        let width, height;

        function resize() {
            const container = document.querySelector('.canvas-container');
            const size = Math.min(container.clientWidth, container.clientHeight) - 20;
            width = height = Math.floor(size);
            canvas.width = width;
            canvas.height = height;
            generate();
        }

        // Descartes Circle Theorem: given 3 mutually tangent circles with curvatures k1, k2, k3,
        // the fourth circle has curvature k4 = k1 + k2 + k3 ± 2*sqrt(k1*k2 + k2*k3 + k3*k1)
        function descartes(k1, k2, k3) {
            const sum = k1 + k2 + k3;
            const prod = Math.sqrt(Math.abs(k1 * k2 + k2 * k3 + k3 * k1));
            return [sum + 2 * prod, sum - 2 * prod];
        }

        // Complex Descartes theorem for centers
        function descartesCenter(c1, c2, c3, k1, k2, k3, k4) {
            const z1 = { re: c1.x * k1, im: c1.y * k1 };
            const z2 = { re: c2.x * k2, im: c2.y * k2 };
            const z3 = { re: c3.x * k3, im: c3.y * k3 };

            const sumZ = { re: z1.re + z2.re + z3.re, im: z1.im + z2.im + z3.im };

            // sqrt(z1*z2 + z2*z3 + z3*z1)
            const prod12 = { re: z1.re * z2.re - z1.im * z2.im, im: z1.re * z2.im + z1.im * z2.re };
            const prod23 = { re: z2.re * z3.re - z2.im * z3.im, im: z2.re * z3.im + z2.im * z3.re };
            const prod31 = { re: z3.re * z1.re - z3.im * z1.im, im: z3.re * z1.im + z3.im * z1.re };
            const sumProd = { re: prod12.re + prod23.re + prod31.re, im: prod12.im + prod23.im + prod31.im };

            const mag = Math.sqrt(sumProd.re * sumProd.re + sumProd.im * sumProd.im);
            const angle = Math.atan2(sumProd.im, sumProd.re) / 2;
            const sqrtProd = { re: Math.sqrt(mag) * Math.cos(angle), im: Math.sqrt(mag) * Math.sin(angle) };

            const center1 = {
                x: (sumZ.re + 2 * sqrtProd.re) / k4,
                y: (sumZ.im + 2 * sqrtProd.im) / k4
            };
            const center2 = {
                x: (sumZ.re - 2 * sqrtProd.re) / k4,
                y: (sumZ.im - 2 * sqrtProd.im) / k4
            };

            return [center1, center2];
        }

        function circleExists(newCircle) {
            for (const c of circles) {
                const dx = c.x - newCircle.x;
                const dy = c.y - newCircle.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < 1 && Math.abs(c.r - newCircle.r) < 1) return true;
            }
            return false;
        }

        function apollonian(c1, c2, c3, depth, maxDepth) {
            if (depth > maxDepth) return;

            const k1 = 1 / c1.r;
            const k2 = 1 / c2.r;
            const k3 = 1 / c3.r;

            const [k4a, k4b] = descartes(k1, k2, k3);

            for (const k4 of [k4a, k4b]) {
                if (Math.abs(k4) < 0.001) continue;
                const r4 = Math.abs(1 / k4);
                if (r4 < 1) continue;

                const centers = descartesCenter(c1, c2, c3, k1, k2, k3, k4);

                for (const center of centers) {
                    const newCircle = { x: center.x, y: center.y, r: r4, depth };

                    if (!circleExists(newCircle) &&
                        newCircle.x > -width && newCircle.x < width * 2 &&
                        newCircle.y > -height && newCircle.y < height * 2) {

                        circles.push(newCircle);

                        apollonian(c1, c2, newCircle, depth + 1, maxDepth);
                        apollonian(c2, c3, newCircle, depth + 1, maxDepth);
                        apollonian(c1, c3, newCircle, depth + 1, maxDepth);
                    }
                }
            }
        }

        function generate() {
            circles = [];
            const maxDepth = parseInt(depthSlider.value);
            document.getElementById('depthVal').textContent = maxDepth;

            const cx = width / 2;
            const cy = height / 2;
            const R = Math.min(width, height) / 2 - 10;

            // Outer circle (negative curvature)
            const outer = { x: cx, y: cy, r: -R, depth: 0 };

            // Three initial tangent circles inside
            const r = R / (1 + 2 / Math.sqrt(3));
            const offset = R - r;

            const c1 = { x: cx, y: cy - offset, r: r, depth: 0 };
            const c2 = { x: cx - offset * Math.sqrt(3) / 2, y: cy + offset / 2, r: r, depth: 0 };
            const c3 = { x: cx + offset * Math.sqrt(3) / 2, y: cy + offset / 2, r: r, depth: 0 };

            circles.push(outer, c1, c2, c3);

            apollonian(outer, c1, c2, 1, maxDepth);
            apollonian(outer, c2, c3, 1, maxDepth);
            apollonian(outer, c1, c3, 1, maxDepth);
            apollonian(c1, c2, c3, 1, maxDepth);

            document.getElementById('circleCount').textContent = circles.length;
            draw();
        }

        function getColor(depth, maxDepth, scheme) {
            const t = depth / maxDepth;
            switch (scheme) {
                case 'rainbow':
                    return `hsl(${t * 300}, 70%, 55%)`;
                case 'cool':
                    return `hsl(${180 + t * 60}, 70%, 55%)`;
                case 'warm':
                    return `hsl(${t * 60}, 80%, 55%)`;
                case 'mono':
                    return `hsl(175, 60%, ${30 + t * 40}%)`;
            }
        }

        function draw() {
            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, width, height);

            const style = styleSelect.value;
            const scheme = colorSelect.value;
            const maxDepth = parseInt(depthSlider.value);

            circles.forEach(c => {
                const r = Math.abs(c.r);
                const color = getColor(c.depth, maxDepth, scheme);

                ctx.beginPath();
                ctx.arc(c.x, c.y, r, 0, Math.PI * 2);

                if (style === 'filled') {
                    ctx.fillStyle = color;
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                } else if (style === 'outline') {
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                } else if (style === 'gradient') {
                    const grad = ctx.createRadialGradient(c.x - r * 0.3, c.y - r * 0.3, 0, c.x, c.y, r);
                    grad.addColorStop(0, 'rgba(255,255,255,0.3)');
                    grad.addColorStop(0.5, color);
                    grad.addColorStop(1, 'rgba(0,0,0,0.5)');
                    ctx.fillStyle = grad;
                    ctx.fill();
                }
            });
        }

        depthSlider.addEventListener('input', generate);
        styleSelect.addEventListener('change', draw);
        colorSelect.addEventListener('change', draw);
        document.getElementById('regenerate').addEventListener('click', generate);

        window.addEventListener('resize', resize);
        resize();
    </script>
</body>
</html>
