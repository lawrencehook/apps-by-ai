<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hyperbolic Tiling - Apps by AI</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            font-family: system-ui, -apple-system, sans-serif;
            background: #0a0a0f;
            height: 100vh;
            overflow: hidden;
            color: #e0e0e0;
        }
        .container {
            height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 12px;
        }
        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        .title-section {
            display: flex;
            align-items: baseline;
            gap: 12px;
        }
        h1 { font-size: 1.3rem; color: #fff; }
        .subtitle { color: #666; font-size: 0.8rem; }
        .back-link {
            color: #666; text-decoration: none; font-size: 13px;
            padding: 6px 12px; background: rgba(255,255,255,0.05);
            border-radius: 6px; border: 1px solid rgba(255,255,255,0.1);
        }
        .back-link:hover { color: #fff; }
        .controls {
            display: flex;
            gap: 16px;
            align-items: center;
            padding: 10px 14px;
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 8px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        label { color: #888; font-size: 0.75rem; }
        select, button {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.15);
            color: #fff; padding: 5px 12px; border-radius: 4px; font-size: 0.8rem;
            cursor: pointer;
        }
        button:hover { background: rgba(255,255,255,0.1); }
        input[type="range"] { width: 80px; accent-color: #4ecdc4; }
        .value { color: #4ecdc4; font-family: monospace; font-size: 0.8rem; min-width: 25px; }
        .btn-primary {
            background: rgba(78, 205, 196, 0.15);
            border-color: rgba(78, 205, 196, 0.3);
            color: #4ecdc4;
        }
        input[type="checkbox"] { accent-color: #4ecdc4; }
        .canvas-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 0;
        }
        canvas {
            max-width: 100%;
            max-height: 100%;
            border-radius: 50%;
        }
        .info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.75rem;
            color: #888;
        }
        .info span { color: #4ecdc4; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="title-section">
                <h1>Hyperbolic Tiling</h1>
                <span class="subtitle">Poincaré disk model tessellations</span>
            </div>
            <a href="../../index.html" class="back-link">← Back</a>
        </div>

        <div class="controls">
            <div class="control-group">
                <label>Tiling {p,q}</label>
                <select id="tiling">
                    <option value="5,4">{5,4} Pentagons</option>
                    <option value="4,5">{4,5} Squares</option>
                    <option value="3,7">{3,7} Triangles</option>
                    <option value="7,3">{7,3} Heptagons</option>
                    <option value="6,4">{6,4} Hexagons</option>
                    <option value="4,6">{4,6} Squares</option>
                    <option value="8,3">{8,3} Octagons</option>
                </select>
            </div>
            <div class="control-group">
                <label>Depth</label>
                <input type="range" id="depth" min="3" max="8" value="5">
                <span class="value" id="depthVal">5</span>
            </div>
            <div class="control-group">
                <label>Color</label>
                <select id="colorScheme">
                    <option value="alternating">Alternating</option>
                    <option value="rainbow">Rainbow</option>
                    <option value="depth">By Depth</option>
                    <option value="mono">Monochrome</option>
                </select>
            </div>
            <div class="control-group">
                <label><input type="checkbox" id="showEdges" checked> Edges</label>
            </div>
            <button class="btn-primary" id="regenerate">Regenerate</button>
        </div>

        <div class="canvas-container">
            <canvas id="canvas"></canvas>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const tilingSelect = document.getElementById('tiling');
        const depthSlider = document.getElementById('depth');
        const colorSelect = document.getElementById('colorScheme');
        const showEdgesCheck = document.getElementById('showEdges');

        let width, height, cx, cy, radius;
        let polygons = [];

        function resize() {
            const container = document.querySelector('.canvas-container');
            const size = Math.min(container.clientWidth, container.clientHeight) - 20;
            width = height = Math.floor(size);
            canvas.width = width;
            canvas.height = height;
            cx = width / 2;
            cy = height / 2;
            radius = (size / 2) - 5;
            generate();
        }

        // Complex number operations in Poincaré disk
        function complexMult(a, b) {
            return { re: a.re * b.re - a.im * b.im, im: a.re * b.im + a.im * b.re };
        }

        function complexDiv(a, b) {
            const denom = b.re * b.re + b.im * b.im;
            return { re: (a.re * b.re + a.im * b.im) / denom, im: (a.im * b.re - a.re * b.im) / denom };
        }

        function complexConj(a) {
            return { re: a.re, im: -a.im };
        }

        function complexAdd(a, b) {
            return { re: a.re + b.re, im: a.im + b.im };
        }

        function complexSub(a, b) {
            return { re: a.re - b.re, im: a.im - b.im };
        }

        function complexAbs(a) {
            return Math.sqrt(a.re * a.re + a.im * a.im);
        }

        // Möbius transformation in Poincaré disk
        function mobiusTransform(z, center, angle) {
            // Rotate
            const cosA = Math.cos(angle);
            const sinA = Math.sin(angle);
            const rotated = { re: z.re * cosA - z.im * sinA, im: z.re * sinA + z.im * cosA };

            // Translate via Möbius
            const conjugate = complexConj(center);
            const num = complexSub(rotated, center);
            const denom = complexSub({ re: 1, im: 0 }, complexMult(conjugate, rotated));
            return complexDiv(num, denom);
        }

        function inverseMobius(z, center, angle) {
            const conjugate = complexConj(center);
            const num = complexAdd(z, center);
            const denom = complexAdd({ re: 1, im: 0 }, complexMult(conjugate, z));
            const translated = complexDiv(num, denom);

            const cosA = Math.cos(-angle);
            const sinA = Math.sin(-angle);
            return { re: translated.re * cosA - translated.im * sinA, im: translated.re * sinA + translated.im * cosA };
        }

        function generate() {
            const [p, q] = tilingSelect.value.split(',').map(Number);
            const maxDepth = parseInt(depthSlider.value);
            document.getElementById('depthVal').textContent = maxDepth;

            polygons = [];

            // Calculate the distance from center to vertex of central polygon
            const angleP = Math.PI / p;
            const angleQ = Math.PI / q;

            // Using hyperbolic trigonometry
            const num = Math.cos(angleP) * Math.cos(angleQ);
            const denom = Math.sin(angleP) * Math.sin(angleQ);
            const coshR = num / denom;
            const r = Math.log(coshR + Math.sqrt(coshR * coshR - 1)); // arcosh
            const vertexDist = Math.tanh(r / 2);

            // Generate central polygon
            const centralVertices = [];
            for (let i = 0; i < p; i++) {
                const angle = (2 * Math.PI * i) / p - Math.PI / 2;
                centralVertices.push({
                    re: vertexDist * Math.cos(angle),
                    im: vertexDist * Math.sin(angle)
                });
            }

            const visited = new Set();

            function polygonKey(vertices) {
                const sorted = vertices.map(v =>
                    `${(v.re * 1000).toFixed(0)},${(v.im * 1000).toFixed(0)}`
                ).sort().join('|');
                return sorted;
            }

            function addPolygon(vertices, depth, colorIdx) {
                const key = polygonKey(vertices);
                if (visited.has(key)) return;
                visited.add(key);

                // Check if polygon is mostly in disk
                const center = vertices.reduce((acc, v) => ({
                    re: acc.re + v.re / vertices.length,
                    im: acc.im + v.im / vertices.length
                }), { re: 0, im: 0 });

                if (complexAbs(center) > 0.99) return;

                polygons.push({ vertices, depth, colorIdx });

                if (depth < maxDepth) {
                    // Reflect across each edge to get neighbors
                    for (let i = 0; i < p; i++) {
                        const v1 = vertices[i];
                        const v2 = vertices[(i + 1) % p];

                        // Calculate reflection
                        const midpoint = { re: (v1.re + v2.re) / 2, im: (v1.im + v2.im) / 2 };
                        const edgeAngle = Math.atan2(v2.im - v1.im, v2.re - v1.re);

                        const newVertices = vertices.map(v => {
                            // Reflect point across the geodesic (edge)
                            const dx = v.re - midpoint.re;
                            const dy = v.im - midpoint.im;
                            const cos2 = Math.cos(2 * edgeAngle);
                            const sin2 = Math.sin(2 * edgeAngle);
                            return {
                                re: midpoint.re + dx * cos2 + dy * sin2,
                                im: midpoint.im + dx * sin2 - dy * cos2
                            };
                        });

                        addPolygon(newVertices, depth + 1, (colorIdx + 1) % 2);
                    }
                }
            }

            addPolygon(centralVertices, 0, 0);
            draw();
        }

        function getColor(polygon, scheme, maxDepth) {
            const { depth, colorIdx } = polygon;
            const t = depth / maxDepth;

            switch (scheme) {
                case 'alternating':
                    return colorIdx === 0 ?
                        `hsl(175, 60%, ${Math.max(10, 45 - depth * 3)}%)` :
                        `hsl(350, 60%, ${Math.max(10, 45 - depth * 3)}%)`;
                case 'rainbow':
                    return `hsl(${(colorIdx * 180 + depth * 30) % 360}, 65%, ${Math.max(10, 50 - depth * 4)}%)`;
                case 'depth':
                    return `hsl(${200 + depth * 20}, 70%, ${Math.max(10, 55 - depth * 5)}%)`;
                case 'mono':
                    const l = Math.max(10, 50 - depth * 6);
                    return colorIdx === 0 ? `hsl(175, 60%, ${l}%)` : `hsl(175, 30%, ${Math.max(5, l - 10)}%)`;
            }
        }

        function draw() {
            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, width, height);

            // Draw disk boundary
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, Math.PI * 2);
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.stroke();

            const scheme = colorSelect.value;
            const maxDepth = parseInt(depthSlider.value);
            const showEdges = showEdgesCheck.checked;

            // Sort by depth (draw deeper first)
            const sorted = [...polygons].sort((a, b) => b.depth - a.depth);

            sorted.forEach(polygon => {
                const { vertices } = polygon;

                ctx.beginPath();
                vertices.forEach((v, i) => {
                    const x = cx + v.re * radius;
                    const y = cy + v.im * radius;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.closePath();

                ctx.fillStyle = getColor(polygon, scheme, maxDepth);
                ctx.fill();

                if (showEdges) {
                    ctx.strokeStyle = 'rgba(0,0,0,0.4)';
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                }
            });

            // Clip to disk
            ctx.globalCompositeOperation = 'destination-in';
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalCompositeOperation = 'source-over';

            // Redraw boundary
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, Math.PI * 2);
            ctx.strokeStyle = '#4ecdc4';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        let generateTimeout = null;
        function debouncedGenerate() {
            document.getElementById('depthVal').textContent = depthSlider.value;
            clearTimeout(generateTimeout);
            generateTimeout = setTimeout(generate, 150);
        }

        tilingSelect.addEventListener('change', generate);
        depthSlider.addEventListener('input', debouncedGenerate);
        colorSelect.addEventListener('change', draw);
        showEdgesCheck.addEventListener('change', draw);
        document.getElementById('regenerate').addEventListener('click', generate);

        window.addEventListener('resize', resize);
        resize();
    </script>
</body>
</html>
