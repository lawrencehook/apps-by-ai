<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Palette Generator - AI Showcase</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: system-ui, -apple-system, sans-serif;
            background: #0a0a0f;
            min-height: 100vh;
            color: #e0e0e0;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 40px 20px;
        }
        h1 { font-size: 1.8rem; margin-bottom: 8px; color: #fff; }
        .subtitle { color: #666; margin-bottom: 32px; }
        .back-link {
            position: fixed; top: 20px; right: 20px; color: #666; text-decoration: none;
            font-size: 14px; padding: 8px 14px; background: rgba(0,0,0,0.85);
            border-radius: 6px; border: 1px solid rgba(255,255,255,0.1);
        }
        .back-link:hover { color: #fff; }
        .controls {
            display: flex;
            gap: 16px;
            margin-bottom: 24px;
            flex-wrap: wrap;
            align-items: center;
        }
        .base-color {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .base-color label { color: #888; font-size: 0.9rem; }
        .color-input {
            width: 50px;
            height: 50px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background: transparent;
        }
        .color-input::-webkit-color-swatch-wrapper { padding: 0; }
        .color-input::-webkit-color-swatch { border-radius: 8px; border: 2px solid rgba(255,255,255,0.2); }
        .mode-select {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.15);
            color: #fff;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 0.9rem;
            cursor: pointer;
        }
        .mode-select:focus { outline: none; border-color: #4ecdc4; }
        .generate-btn {
            background: rgba(78, 205, 196, 0.2);
            border: 1px solid rgba(78, 205, 196, 0.4);
            color: #4ecdc4;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            margin-left: auto;
        }
        .generate-btn:hover { background: rgba(78, 205, 196, 0.3); }
        .palette-display {
            display: flex;
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 24px;
            height: 200px;
        }
        .palette-color {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            padding: 16px;
            cursor: pointer;
            transition: flex 0.2s;
            position: relative;
        }
        .palette-color:hover { flex: 1.3; }
        .palette-color.locked::before {
            content: 'üîí';
            position: absolute;
            top: 12px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.2rem;
        }
        .color-hex {
            font-family: monospace;
            font-size: 0.9rem;
            font-weight: 600;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }
        .color-name {
            font-size: 0.75rem;
            opacity: 0.8;
            margin-top: 4px;
        }
        .palette-actions {
            display: flex;
            gap: 12px;
            margin-bottom: 24px;
        }
        .action-btn {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            color: #888;
            padding: 10px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
        }
        .action-btn:hover { background: rgba(255,255,255,0.1); color: #fff; }
        .export-section {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 12px;
            padding: 24px;
        }
        .export-title { color: #888; font-size: 0.9rem; margin-bottom: 16px; }
        .export-formats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
        }
        .export-format {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 8px;
            padding: 12px;
        }
        .format-label { color: #666; font-size: 0.8rem; margin-bottom: 8px; }
        .format-value {
            font-family: monospace;
            font-size: 0.85rem;
            color: #fff;
            word-break: break-all;
            max-height: 60px;
            overflow-y: auto;
        }
        .copy-format {
            background: transparent;
            border: none;
            color: #4ecdc4;
            cursor: pointer;
            font-size: 0.8rem;
            float: right;
            margin-top: 8px;
        }
        .tip { color: #666; font-size: 0.8rem; margin-top: 16px; text-align: center; }
    </style>
</head>
<body>
    <a href="../../index.html" class="back-link">‚Üê Back</a>
    <div class="container">
        <h1>Palette Generator</h1>
        <p class="subtitle">Generate beautiful color palettes using color theory.</p>

        <div class="controls">
            <div class="base-color">
                <label>Base Color</label>
                <input type="color" class="color-input" id="baseColor" value="#4ecdc4">
            </div>
            <select class="mode-select" id="harmonyMode">
                <option value="complementary">Complementary</option>
                <option value="analogous">Analogous</option>
                <option value="triadic">Triadic</option>
                <option value="split-complementary">Split Complementary</option>
                <option value="tetradic">Tetradic</option>
                <option value="monochromatic">Monochromatic</option>
                <option value="random">Random</option>
            </select>
            <button class="generate-btn" id="generateBtn">Generate New</button>
        </div>

        <div class="palette-display" id="paletteDisplay"></div>

        <div class="palette-actions">
            <button class="action-btn" id="randomizeBtn">üé≤ Randomize</button>
            <button class="action-btn" id="copyAllBtn">üìã Copy All</button>
        </div>

        <div class="export-section">
            <div class="export-title">Export Formats</div>
            <div class="export-formats" id="exportFormats"></div>
        </div>

        <p class="tip">Click a color to lock it, then generate new palettes around locked colors.</p>
    </div>

    <script>
        let palette = [];
        let locked = [false, false, false, false, false];

        function hexToHsl(hex) {
            let r = parseInt(hex.slice(1, 3), 16) / 255;
            let g = parseInt(hex.slice(3, 5), 16) / 255;
            let b = parseInt(hex.slice(5, 7), 16) / 255;

            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                    case g: h = ((b - r) / d + 2) / 6; break;
                    case b: h = ((r - g) / d + 4) / 6; break;
                }
            }
            return { h: h * 360, s: s * 100, l: l * 100 };
        }

        function hslToHex(h, s, l) {
            h = ((h % 360) + 360) % 360;
            s = Math.max(0, Math.min(100, s)) / 100;
            l = Math.max(0, Math.min(100, l)) / 100;

            const c = (1 - Math.abs(2 * l - 1)) * s;
            const x = c * (1 - Math.abs((h / 60) % 2 - 1));
            const m = l - c / 2;

            let r, g, b;
            if (h < 60) { r = c; g = x; b = 0; }
            else if (h < 120) { r = x; g = c; b = 0; }
            else if (h < 180) { r = 0; g = c; b = x; }
            else if (h < 240) { r = 0; g = x; b = c; }
            else if (h < 300) { r = x; g = 0; b = c; }
            else { r = c; g = 0; b = x; }

            const toHex = v => Math.round((v + m) * 255).toString(16).padStart(2, '0');
            return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
        }

        function getLuminance(hex) {
            const r = parseInt(hex.slice(1, 3), 16) / 255;
            const g = parseInt(hex.slice(3, 5), 16) / 255;
            const b = parseInt(hex.slice(5, 7), 16) / 255;
            return 0.299 * r + 0.587 * g + 0.114 * b;
        }

        function generatePalette() {
            const base = document.getElementById('baseColor').value;
            const mode = document.getElementById('harmonyMode').value;
            const hsl = hexToHsl(base);
            let newPalette = [];

            switch (mode) {
                case 'complementary':
                    newPalette = [
                        base,
                        hslToHex(hsl.h, hsl.s * 0.7, hsl.l + 15),
                        hslToHex(hsl.h, hsl.s * 0.5, hsl.l + 25),
                        hslToHex(hsl.h + 180, hsl.s * 0.7, hsl.l + 10),
                        hslToHex(hsl.h + 180, hsl.s, hsl.l)
                    ];
                    break;
                case 'analogous':
                    newPalette = [
                        hslToHex(hsl.h - 30, hsl.s, hsl.l),
                        hslToHex(hsl.h - 15, hsl.s * 0.9, hsl.l + 10),
                        base,
                        hslToHex(hsl.h + 15, hsl.s * 0.9, hsl.l + 10),
                        hslToHex(hsl.h + 30, hsl.s, hsl.l)
                    ];
                    break;
                case 'triadic':
                    newPalette = [
                        base,
                        hslToHex(hsl.h, hsl.s * 0.6, hsl.l + 20),
                        hslToHex(hsl.h + 120, hsl.s, hsl.l),
                        hslToHex(hsl.h + 120, hsl.s * 0.6, hsl.l + 15),
                        hslToHex(hsl.h + 240, hsl.s, hsl.l)
                    ];
                    break;
                case 'split-complementary':
                    newPalette = [
                        base,
                        hslToHex(hsl.h, hsl.s * 0.7, hsl.l + 20),
                        hslToHex(hsl.h + 150, hsl.s, hsl.l),
                        hslToHex(hsl.h + 180, hsl.s * 0.5, hsl.l + 15),
                        hslToHex(hsl.h + 210, hsl.s, hsl.l)
                    ];
                    break;
                case 'tetradic':
                    newPalette = [
                        base,
                        hslToHex(hsl.h + 90, hsl.s, hsl.l),
                        hslToHex(hsl.h + 180, hsl.s, hsl.l),
                        hslToHex(hsl.h + 270, hsl.s, hsl.l),
                        hslToHex(hsl.h, hsl.s * 0.5, hsl.l + 25)
                    ];
                    break;
                case 'monochromatic':
                    newPalette = [
                        hslToHex(hsl.h, hsl.s, 15),
                        hslToHex(hsl.h, hsl.s * 0.9, 35),
                        base,
                        hslToHex(hsl.h, hsl.s * 0.7, 65),
                        hslToHex(hsl.h, hsl.s * 0.5, 85)
                    ];
                    break;
                case 'random':
                    for (let i = 0; i < 5; i++) {
                        if (locked[i] && palette[i]) {
                            newPalette.push(palette[i]);
                        } else {
                            newPalette.push(hslToHex(Math.random() * 360, 50 + Math.random() * 40, 40 + Math.random() * 30));
                        }
                    }
                    break;
            }

            // Preserve locked colors
            palette = newPalette.map((color, i) => locked[i] && palette[i] ? palette[i] : color);
            renderPalette();
        }

        function renderPalette() {
            const container = document.getElementById('paletteDisplay');
            container.innerHTML = palette.map((color, i) => {
                const isLight = getLuminance(color) > 0.5;
                const textColor = isLight ? '#000' : '#fff';
                return `
                    <div class="palette-color ${locked[i] ? 'locked' : ''}"
                         style="background-color: ${color}; color: ${textColor}"
                         data-index="${i}">
                        <div class="color-hex">${color.toUpperCase()}</div>
                    </div>
                `;
            }).join('');

            container.querySelectorAll('.palette-color').forEach(el => {
                el.addEventListener('click', () => {
                    const idx = parseInt(el.dataset.index);
                    locked[idx] = !locked[idx];
                    renderPalette();
                });
            });

            updateExports();
        }

        function updateExports() {
            const container = document.getElementById('exportFormats');
            const hexArray = palette.map(c => c.toUpperCase());
            const rgbArray = palette.map(hex => {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return `rgb(${r}, ${g}, ${b})`;
            });

            const formats = [
                { label: 'CSS Variables', value: palette.map((c, i) => `--color-${i + 1}: ${c};`).join('\n') },
                { label: 'HEX Array', value: JSON.stringify(hexArray) },
                { label: 'Tailwind Config', value: `colors: {\n  palette: {\n${palette.map((c, i) => `    ${(i + 1) * 100}: '${c}'`).join(',\n')}\n  }\n}` },
                { label: 'SCSS Variables', value: palette.map((c, i) => `$color-${i + 1}: ${c};`).join('\n') }
            ];

            container.innerHTML = formats.map(f => `
                <div class="export-format">
                    <div class="format-label">${f.label}</div>
                    <div class="format-value">${f.value.replace(/\n/g, '<br>')}</div>
                    <button class="copy-format" data-value="${encodeURIComponent(f.value)}">Copy</button>
                </div>
            `).join('');

            container.querySelectorAll('.copy-format').forEach(btn => {
                btn.addEventListener('click', () => {
                    navigator.clipboard.writeText(decodeURIComponent(btn.dataset.value));
                    btn.textContent = 'Copied!';
                    setTimeout(() => btn.textContent = 'Copy', 1500);
                });
            });
        }

        document.getElementById('baseColor').addEventListener('input', generatePalette);
        document.getElementById('harmonyMode').addEventListener('change', generatePalette);
        document.getElementById('generateBtn').addEventListener('click', generatePalette);

        document.getElementById('randomizeBtn').addEventListener('click', () => {
            document.getElementById('baseColor').value = hslToHex(Math.random() * 360, 50 + Math.random() * 40, 45 + Math.random() * 20);
            generatePalette();
        });

        document.getElementById('copyAllBtn').addEventListener('click', () => {
            navigator.clipboard.writeText(palette.join(', '));
            const btn = document.getElementById('copyAllBtn');
            btn.textContent = '‚úì Copied!';
            setTimeout(() => btn.textContent = 'üìã Copy All', 1500);
        });

        // Spacebar to regenerate
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && !['INPUT', 'SELECT', 'BUTTON', 'TEXTAREA'].includes(e.target.tagName)) {
                e.preventDefault();
                generatePalette();
            }
        });

        generatePalette();
    </script>
</body>
</html>
