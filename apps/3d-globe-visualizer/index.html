<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Globe Visualizer - AI Showcase</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a0f;
            overflow: hidden;
            font-family: system-ui, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        canvas { display: block; cursor: grab; }
        canvas:active { cursor: grabbing; }
        .controls {
            position: fixed; top: 20px; left: 20px; background: rgba(0,0,0,0.85);
            padding: 16px; border-radius: 8px; color: #fff; font-size: 14px;
            min-width: 200px; border: 1px solid rgba(255,255,255,0.1);
            max-height: calc(100vh - 40px); overflow-y: auto;
            transition: all 0.3s ease;
        }
        .controls.minimized {
            padding: 8px 16px;
        }
        .controls.minimized .controls-content { display: none; }
        .controls-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 12px;
        }
        .controls.minimized .controls-header { margin-bottom: 0; }
        .controls h1 { font-size: 1.1rem; margin: 0; }
        .minimize-btn {
            background: none; border: none; color: #666; cursor: pointer;
            font-size: 18px; padding: 0; margin: 0; line-height: 1;
        }
        .minimize-btn:hover { color: #fff; background: none; }
        .controls p { color: #555; margin-bottom: 14px; line-height: 1.4; font-size: 12px; }
        button {
            background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2);
            color: #fff; padding: 6px 12px; border-radius: 4px; cursor: pointer;
            font-size: 12px; margin-right: 4px; margin-bottom: 4px; transition: all 0.2s;
        }
        button:hover { background: rgba(255,255,255,0.2); }
        button.active { background: rgba(100, 200, 255, 0.3); border-color: rgba(100, 200, 255, 0.5); }
        .control-group { margin-bottom: 12px; }
        .control-group label { display: block; margin-bottom: 4px; color: #888; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; }
        .control-group input[type="range"] { width: 120px; }
        .back-link {
            position: fixed; top: 20px; right: 20px; color: #666; text-decoration: none;
            font-size: 14px; padding: 8px 14px; background: rgba(0,0,0,0.85);
            border-radius: 6px; border: 1px solid rgba(255,255,255,0.1);
        }
        .back-link:hover { color: #fff; }
        .stats {
            position: fixed; bottom: 20px; left: 20px; background: rgba(0,0,0,0.85);
            padding: 12px 16px; border-radius: 8px; color: #666; font-size: 12px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .data-layer {
            display: flex; align-items: center; padding: 5px 0;
        }
        .data-layer input { display: none; }
        .data-layer span { font-size: 12px; }
        .color-dot {
            width: 8px; height: 8px; border-radius: 50%; margin-right: 6px; display: inline-block;
        }
        .toggle {
            position: relative; width: 32px; height: 18px; margin-right: 8px; flex-shrink: 0;
        }
        .toggle-slider {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255,255,255,0.15); border-radius: 9px; cursor: pointer;
            transition: 0.2s;
        }
        .toggle-slider:before {
            position: absolute; content: ""; height: 12px; width: 12px;
            left: 3px; bottom: 3px; background: #666; border-radius: 50%;
            transition: 0.2s;
        }
        .data-layer input:checked + .toggle .toggle-slider { background: rgba(78, 205, 196, 0.4); }
        .data-layer input:checked + .toggle .toggle-slider:before { transform: translateX(14px); background: #4ecdc4; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="controls" id="controls">
        <div class="controls-header">
            <h1>3D Globe</h1>
            <button class="minimize-btn" id="minimizeBtn">−</button>
        </div>
        <div class="controls-content">
            <p>Drag to rotate, scroll to zoom, double-click to reset.</p>

            <div class="control-group">
                <label>Data Layers</label>
                <div class="data-layer">
                    <input type="checkbox" id="showCities" checked>
                    <label class="toggle" for="showCities"><span class="toggle-slider"></span></label>
                    <span class="color-dot" style="background: #ffcc00;"></span>
                    <span>Cities</span>
                </div>
                <div class="data-layer">
                    <input type="checkbox" id="showFlights">
                    <label class="toggle" for="showFlights"><span class="toggle-slider"></span></label>
                    <span class="color-dot" style="background: #00ff88;"></span>
                    <span>Flights</span>
                </div>
                <div class="data-layer">
                    <input type="checkbox" id="showQuakes">
                    <label class="toggle" for="showQuakes"><span class="toggle-slider"></span></label>
                    <span class="color-dot" style="background: #ff4444;"></span>
                    <span>Quakes</span>
                </div>
                <div class="data-layer">
                    <input type="checkbox" id="showGrid">
                    <label class="toggle" for="showGrid"><span class="toggle-slider"></span></label>
                    <span class="color-dot" style="background: #4488ff;"></span>
                    <span>Grid</span>
                </div>
            </div>

            <div class="control-group">
                <label>Rotation: <span id="speedLabel">0.2</span></label>
                <input type="range" id="speed" min="0" max="2" step="0.1" value="0.2">
            </div>

            <div class="control-group">
                <label>Style</label>
                <button id="styleReal" class="active">Realistic</button>
                <button id="styleWire">Wire</button>
                <button id="styleGlow">Neon</button>
            </div>
        </div>
    </div>
    <a href="../../index.html" class="back-link">← Back</a>
    <div class="stats" id="stats">Hover over a city for details</div>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/topojson-client@3"></script>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const stats = document.getElementById('stats');

        let width, height, radius;
        let rotation = [0, -20, 0]; // lambda, phi, gamma
        let autoRotateSpeed = 0.2;
        let zoom = 1;
        let isDragging = false;
        let lastMouseX, lastMouseY;
        let globeStyle = 'real';
        let landData = null;

        // D3 projection
        let projection = d3.geoOrthographic()
            .clipAngle(90)
            .precision(0.5);

        let path = d3.geoPath(projection, ctx);

        // Major world cities with lat/long
        const cities = [
            { name: 'New York', lat: 40.7128, lon: -74.0060, pop: 8.3 },
            { name: 'London', lat: 51.5074, lon: -0.1278, pop: 8.9 },
            { name: 'Tokyo', lat: 35.6762, lon: 139.6503, pop: 13.9 },
            { name: 'Paris', lat: 48.8566, lon: 2.3522, pop: 2.1 },
            { name: 'Sydney', lat: -33.8688, lon: 151.2093, pop: 5.3 },
            { name: 'Dubai', lat: 25.2048, lon: 55.2708, pop: 3.3 },
            { name: 'Singapore', lat: 1.3521, lon: 103.8198, pop: 5.6 },
            { name: 'Los Angeles', lat: 34.0522, lon: -118.2437, pop: 4.0 },
            { name: 'Mumbai', lat: 19.0760, lon: 72.8777, pop: 12.4 },
            { name: 'São Paulo', lat: -23.5505, lon: -46.6333, pop: 12.3 },
            { name: 'Cairo', lat: 30.0444, lon: 31.2357, pop: 9.5 },
            { name: 'Moscow', lat: 55.7558, lon: 37.6173, pop: 11.9 },
            { name: 'Beijing', lat: 39.9042, lon: 116.4074, pop: 21.5 },
            { name: 'Rio de Janeiro', lat: -22.9068, lon: -43.1729, pop: 6.7 },
            { name: 'Cape Town', lat: -33.9249, lon: 18.4241, pop: 4.6 },
            { name: 'Mexico City', lat: 19.4326, lon: -99.1332, pop: 8.8 },
            { name: 'Toronto', lat: 43.6532, lon: -79.3832, pop: 2.7 },
            { name: 'Berlin', lat: 52.5200, lon: 13.4050, pop: 3.6 },
            { name: 'Bangkok', lat: 13.7563, lon: 100.5018, pop: 8.3 },
            { name: 'Seoul', lat: 37.5665, lon: 126.9780, pop: 9.7 }
        ];

        // Flight paths (city pairs)
        const flights = [
            [0, 1], [0, 2], [1, 3], [2, 6], [0, 12], [1, 11],
            [4, 6], [5, 8], [9, 13], [10, 5], [0, 15], [1, 17],
            [2, 18], [6, 12], [3, 11], [14, 1], [16, 0], [7, 2]
        ];

        // Earthquake zones
        const quakeZones = [
            { lat: 35.6, lon: 139.6, intensity: 0.9, name: 'Japan Trench' },
            { lat: -33.4, lon: -70.6, intensity: 0.85, name: 'Chile Coast' },
            { lat: 37.7, lon: -122.4, intensity: 0.7, name: 'San Andreas' },
            { lat: 28.2, lon: 84.1, intensity: 0.8, name: 'Nepal Himalayas' },
            { lat: -6.2, lon: 106.8, intensity: 0.75, name: 'Indonesia' },
            { lat: 38.0, lon: 23.7, intensity: 0.6, name: 'Greece' },
            { lat: 40.4, lon: 49.8, intensity: 0.65, name: 'Azerbaijan' },
            { lat: -41.2, lon: 174.7, intensity: 0.7, name: 'New Zealand' }
        ];

        // Graticule for lat/long grid
        const graticule = d3.geoGraticule10();

        // Load land data
        fetch('land-110m.json')
            .then(r => r.json())
            .then(topology => {
                landData = topojson.feature(topology, topology.objects.land);
                console.log('Land data loaded');
            })
            .catch(err => console.error('Failed to load land data:', err));

        // Stars background
        let stars = [];
        function generateStars() {
            stars = [];
            for (let i = 0; i < 200; i++) {
                stars.push({
                    x: Math.random() * width,
                    y: Math.random() * height,
                    size: Math.random() * 1.5,
                    alpha: Math.random() * 0.5 + 0.2
                });
            }
        }

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            radius = Math.min(width, height) * 0.35 * zoom;

            projection
                .translate([width / 2, height / 2])
                .scale(radius);

            generateStars();
        }

        function isVisible(lon, lat) {
            // Check if point is on visible hemisphere using spherical distance
            // D3 rotate([lambda, phi]) places center of view at [-lambda, -phi]
            const lambda = rotation[0] * Math.PI / 180;
            const phi = -rotation[1] * Math.PI / 180; // Negate to get center latitude
            const lonRad = lon * Math.PI / 180;
            const latRad = lat * Math.PI / 180;

            // Calculate angular distance from center of view
            const cosDistance = Math.sin(phi) * Math.sin(latRad) +
                               Math.cos(phi) * Math.cos(latRad) * Math.cos(lonRad + lambda);

            return cosDistance > 0; // Visible if less than 90 degrees from center
        }

        function drawGlobe() {
            ctx.clearRect(0, 0, width, height);

            // Update projection rotation
            projection.rotate(rotation);

            // Draw stars
            ctx.fillStyle = '#fff';
            for (const star of stars) {
                ctx.globalAlpha = star.alpha;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            const centerX = width / 2;
            const centerY = height / 2;

            // Draw globe base
            if (globeStyle === 'real') {
                const gradient = ctx.createRadialGradient(
                    centerX - radius * 0.3, centerY - radius * 0.3, 0,
                    centerX, centerY, radius
                );
                gradient.addColorStop(0, '#1a3a5c');
                gradient.addColorStop(0.5, '#0d2137');
                gradient.addColorStop(1, '#051525');
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
            } else if (globeStyle === 'glow') {
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0, 20, 40, 0.8)';
                ctx.fill();
                ctx.shadowColor = '#00aaff';
                ctx.shadowBlur = 30;
                ctx.strokeStyle = '#00aaff';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.shadowBlur = 0;
            } else {
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(100, 150, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            // Draw land using D3 path generator (handles clipping automatically)
            if (landData) {
                ctx.beginPath();
                path(landData);

                if (globeStyle === 'real') {
                    ctx.fillStyle = 'rgba(34, 100, 60, 0.8)';
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(60, 130, 80, 0.6)';
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                } else if (globeStyle === 'glow') {
                    ctx.shadowColor = '#00ff88';
                    ctx.shadowBlur = 10;
                    ctx.strokeStyle = '#00ff88';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                } else {
                    ctx.strokeStyle = 'rgba(100, 180, 255, 0.6)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }

            // Draw graticule (lat/long grid)
            if (document.getElementById('showGrid').checked) {
                ctx.beginPath();
                path(graticule);
                ctx.strokeStyle = globeStyle === 'glow' ? 'rgba(68, 136, 255, 0.4)' : 'rgba(68, 136, 255, 0.15)';
                ctx.lineWidth = 0.5;
                ctx.stroke();
            }

            // Draw earthquake zones
            if (document.getElementById('showQuakes').checked) {
                for (const zone of quakeZones) {
                    if (!isVisible(zone.lon, zone.lat)) continue;
                    const pos = projection([zone.lon, zone.lat]);
                    const baseSize = 20 * zone.intensity;
                    const pulseSize = baseSize + Math.sin(Date.now() / 200) * 5;

                    ctx.beginPath();
                    ctx.arc(pos[0], pos[1], pulseSize, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(255, 68, 68, ${0.5 * zone.intensity})`;
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.arc(pos[0], pos[1], 5, 0, Math.PI * 2);
                    ctx.fillStyle = '#ff4444';
                    ctx.fill();
                }
            }

            // Draw flight paths
            if (document.getElementById('showFlights').checked) {
                ctx.strokeStyle = '#00ff88';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);

                for (const [from, to] of flights) {
                    const city1 = cities[from];
                    const city2 = cities[to];

                    // Only draw if at least part of the route is visible
                    const v1 = isVisible(city1.lon, city1.lat);
                    const v2 = isVisible(city2.lon, city2.lat);
                    if (!v1 && !v2) continue;

                    // Create great circle path - D3 will handle clipping
                    const lineGeo = {
                        type: 'LineString',
                        coordinates: [[city1.lon, city1.lat], [city2.lon, city2.lat]]
                    };

                    ctx.beginPath();
                    path(lineGeo);
                    ctx.stroke();

                    // Animated plane dot - only show if position is visible
                    const t = (Date.now() % 3000) / 3000;
                    const interpLon = city1.lon + (city2.lon - city1.lon) * t;
                    const interpLat = city1.lat + (city2.lat - city1.lat) * t;

                    if (isVisible(interpLon, interpLat)) {
                        const planePos = projection([interpLon, interpLat]);
                        if (planePos) {
                            ctx.beginPath();
                            ctx.arc(planePos[0], planePos[1], 3, 0, Math.PI * 2);
                            ctx.fillStyle = '#00ff88';
                            ctx.fill();
                        }
                    }
                }
                ctx.setLineDash([]);
            }

            // Draw cities
            if (document.getElementById('showCities').checked) {
                for (const city of cities) {
                    if (!isVisible(city.lon, city.lat)) continue;
                    const pos = projection([city.lon, city.lat]);
                    const size = 3 + city.pop / 5;

                    // Glow effect
                    ctx.beginPath();
                    ctx.arc(pos[0], pos[1], size * 2, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 200, 50, 0.2)';
                    ctx.fill();

                    // City dot
                    ctx.beginPath();
                    ctx.arc(pos[0], pos[1], size, 0, Math.PI * 2);
                    ctx.fillStyle = '#ffcc00';
                    ctx.fill();

                    // City name
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.font = '11px system-ui';
                    ctx.fillText(city.name, pos[0] + size + 4, pos[1] + 4);
                }
            }

            // Atmosphere glow
            if (globeStyle === 'real' || globeStyle === 'glow') {
                const atmosphereGradient = ctx.createRadialGradient(
                    centerX, centerY, radius * 0.95,
                    centerX, centerY, radius * 1.15
                );
                atmosphereGradient.addColorStop(0, 'rgba(100, 180, 255, 0.15)');
                atmosphereGradient.addColorStop(0.5, 'rgba(100, 180, 255, 0.05)');
                atmosphereGradient.addColorStop(1, 'rgba(100, 180, 255, 0)');
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius * 1.15, 0, Math.PI * 2);
                ctx.fillStyle = atmosphereGradient;
                ctx.fill();
            }
        }

        function animate() {
            rotation[0] += autoRotateSpeed;
            drawGlobe();
            requestAnimationFrame(animate);
        }

        // Drag to rotate
        canvas.addEventListener('mousedown', e => {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        canvas.addEventListener('mousemove', e => {
            if (isDragging) {
                const deltaX = e.clientX - lastMouseX;
                const deltaY = e.clientY - lastMouseY;
                const sensitivity = 0.3 / zoom;
                rotation[0] += deltaX * sensitivity;
                rotation[1] -= deltaY * sensitivity;
                rotation[1] = Math.max(-90, Math.min(90, rotation[1]));
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            }

            // Hover detection for cities
            if (document.getElementById('showCities').checked) {
                let hoveredCity = null;
                for (const city of cities) {
                    if (!isVisible(city.lon, city.lat)) continue;
                    const pos = projection([city.lon, city.lat]);
                    const dist = Math.sqrt((e.clientX - pos[0]) ** 2 + (e.clientY - pos[1]) ** 2);
                    if (dist < 15) {
                        hoveredCity = city;
                        break;
                    }
                }
                if (hoveredCity) {
                    stats.innerHTML = `<strong>${hoveredCity.name}</strong><br>Pop: ${hoveredCity.pop}M | Lat: ${hoveredCity.lat.toFixed(2)}° Lon: ${hoveredCity.lon.toFixed(2)}°`;
                } else {
                    stats.textContent = 'Hover over a city for details';
                }
            }
        });

        canvas.addEventListener('mouseup', () => isDragging = false);
        canvas.addEventListener('mouseleave', () => isDragging = false);

        // Touch support
        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            const touch = e.touches[0];
            isDragging = true;
            lastMouseX = touch.clientX;
            lastMouseY = touch.clientY;
        }, { passive: false });

        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            if (isDragging && e.touches.length === 1) {
                const touch = e.touches[0];
                const deltaX = touch.clientX - lastMouseX;
                const deltaY = touch.clientY - lastMouseY;
                const sensitivity = 0.3 / zoom;
                rotation[0] += deltaX * sensitivity;
                rotation[1] -= deltaY * sensitivity;
                rotation[1] = Math.max(-90, Math.min(90, rotation[1]));
                lastMouseX = touch.clientX;
                lastMouseY = touch.clientY;
            }
        }, { passive: false });

        canvas.addEventListener('touchend', () => isDragging = false);

        canvas.addEventListener('wheel', e => {
            e.preventDefault();
            zoom *= e.deltaY > 0 ? 0.95 : 1.05;
            zoom = Math.max(0.5, Math.min(5, zoom));
            radius = Math.min(width, height) * 0.35 * zoom;
            projection.scale(radius);
        }, { passive: false });

        canvas.addEventListener('dblclick', () => {
            rotation = [0, -20, 0];
            zoom = 1;
            radius = Math.min(width, height) * 0.35;
            projection.scale(radius);
        });

        document.getElementById('speed').addEventListener('input', e => {
            autoRotateSpeed = parseFloat(e.target.value);
            document.getElementById('speedLabel').textContent = e.target.value;
        });

        document.getElementById('minimizeBtn').addEventListener('click', () => {
            const controls = document.getElementById('controls');
            const btn = document.getElementById('minimizeBtn');
            controls.classList.toggle('minimized');
            btn.textContent = controls.classList.contains('minimized') ? '+' : '−';
        });

        ['styleReal', 'styleWire', 'styleGlow'].forEach(id => {
            document.getElementById(id).addEventListener('click', e => {
                document.querySelectorAll('.control-group button').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                globeStyle = id.replace('style', '').toLowerCase();
            });
        });

        window.addEventListener('resize', resize);

        resize();
        animate();
    </script>
</body>
</html>
