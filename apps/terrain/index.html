<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Terrain Generator - AI Showcase</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #000; overflow: hidden; font-family: system-ui, sans-serif; }
        canvas { display: block; cursor: grab; }
        canvas:active { cursor: grabbing; }
        .controls {
            position: fixed; top: 20px; left: 20px; background: rgba(0,0,0,0.85);
            padding: 20px; border-radius: 8px; color: #fff; font-size: 14px;
            min-width: 220px; border: 1px solid rgba(255,255,255,0.1);
        }
        .controls h1 { font-size: 1.3rem; margin-bottom: 8px; }
        .controls p { color: #666; margin-bottom: 16px; line-height: 1.4; font-size: 13px; }
        button {
            background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2);
            color: #fff; padding: 8px 14px; border-radius: 4px; cursor: pointer;
            font-size: 13px; margin-right: 6px; margin-bottom: 6px;
        }
        button:hover { background: rgba(255,255,255,0.2); }
        button.active { background: rgba(100,200,100,0.3); border-color: rgba(100,200,100,0.5); }
        .control-group { margin-bottom: 12px; }
        .control-group label { display: block; margin-bottom: 4px; color: #888; font-size: 12px; }
        .control-group input[type="range"] { width: 100%; }
        .back-link {
            position: fixed; top: 20px; right: 20px; color: #666; text-decoration: none;
            font-size: 14px; padding: 8px 14px; background: rgba(0,0,0,0.85);
            border-radius: 6px; border: 1px solid rgba(255,255,255,0.1);
        }
        .back-link:hover { color: #fff; }
        .hint { color: #555; font-size: 11px; margin-top: 12px; line-height: 1.4; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="controls">
        <h1>Terrain Generator</h1>
        <p>Procedural landscape with sculpting. Drag to rotate, scroll to zoom.</p>
        <div class="control-group">
            <label>Height Scale: <span id="heightLabel">80</span></label>
            <input type="range" id="height" min="20" max="150" value="80">
        </div>
        <div class="control-group">
            <label>Water Level: <span id="waterLabel">0.35</span></label>
            <input type="range" id="water" min="0" max="0.6" step="0.05" value="0.35">
        </div>
        <div class="control-group">
            <label>Time of Day: <span id="timeLabel">12:00</span></label>
            <input type="range" id="timeOfDay" min="0" max="24" step="0.5" value="12">
        </div>
        <div class="control-group">
            <label>Brush Size: <span id="brushLabel">3</span></label>
            <input type="range" id="brush" min="1" max="8" value="3">
        </div>
        <button id="raise" class="active">Raise</button>
        <button id="lower">Lower</button>
        <button id="flatten">Flatten</button>
        <button id="regenerate">Regenerate</button>
        <div class="hint">Click terrain to sculpt. Hold Shift to lower.</div>
    </div>
    <a href="../../index.html" class="back-link">‚Üê Back</a>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let heightScale = 80;
        let waterLevel = 0.35;
        let seed = Math.random() * 10000;
        let time = 0;
        let timeOfDay = 12;
        let brushSize = 3;
        let sculptMode = 'raise'; // 'raise', 'lower', 'flatten'

        const GRID_SIZE = 80;
        let TILE_WIDTH = 12;
        let TILE_HEIGHT = 6;
        let zoom = 1;
        let rotation = 0; // in radians
        let targetRotation = 0;

        // Terrain height data (persistent for sculpting)
        let terrainData = [];

        // Interaction state
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let isSculpting = false;

        // Simple noise function
        function noise(x, y) {
            const n = Math.sin(x * 12.9898 + y * 78.233 + seed) * 43758.5453;
            return n - Math.floor(n);
        }

        function smoothNoise(x, y) {
            const corners = (noise(x-1, y-1) + noise(x+1, y-1) + noise(x-1, y+1) + noise(x+1, y+1)) / 16;
            const sides = (noise(x-1, y) + noise(x+1, y) + noise(x, y-1) + noise(x, y+1)) / 8;
            const center = noise(x, y) / 4;
            return corners + sides + center;
        }

        function interpolatedNoise(x, y) {
            const ix = Math.floor(x);
            const iy = Math.floor(y);
            const fx = x - ix;
            const fy = y - iy;

            const v1 = smoothNoise(ix, iy);
            const v2 = smoothNoise(ix + 1, iy);
            const v3 = smoothNoise(ix, iy + 1);
            const v4 = smoothNoise(ix + 1, iy + 1);

            const i1 = v1 * (1 - fx) + v2 * fx;
            const i2 = v3 * (1 - fx) + v4 * fx;

            return i1 * (1 - fy) + i2 * fy;
        }

        function perlin(x, y) {
            let total = 0;
            let frequency = 0.05;
            let amplitude = 1;
            let maxValue = 0;

            for (let i = 0; i < 5; i++) {
                total += interpolatedNoise(x * frequency, y * frequency) * amplitude;
                maxValue += amplitude;
                amplitude *= 0.5;
                frequency *= 2;
            }

            return total / maxValue;
        }

        function generateTerrain() {
            terrainData = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                terrainData[y] = [];
                for (let x = 0; x < GRID_SIZE; x++) {
                    terrainData[y][x] = perlin(x, y);
                }
            }
        }

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }

        function getSkyColor() {
            // Time of day affects sky color
            const t = timeOfDay;
            if (t < 5 || t > 21) {
                // Night
                return { sky: '#0a0a1a', ambient: 0.3 };
            } else if (t < 7) {
                // Dawn
                const f = (t - 5) / 2;
                return {
                    sky: lerpColor('#0a0a1a', '#ff7b54', f),
                    ambient: 0.3 + f * 0.4
                };
            } else if (t < 9) {
                // Morning
                const f = (t - 7) / 2;
                return {
                    sky: lerpColor('#ff7b54', '#1a1a2e', f),
                    ambient: 0.7 + f * 0.3
                };
            } else if (t < 17) {
                // Day
                return { sky: '#1a1a2e', ambient: 1.0 };
            } else if (t < 19) {
                // Evening
                const f = (t - 17) / 2;
                return {
                    sky: lerpColor('#1a1a2e', '#ff6b35', f),
                    ambient: 1.0 - f * 0.3
                };
            } else {
                // Dusk
                const f = (t - 19) / 2;
                return {
                    sky: lerpColor('#ff6b35', '#0a0a1a', f),
                    ambient: 0.7 - f * 0.4
                };
            }
        }

        function lerpColor(c1, c2, f) {
            const r1 = parseInt(c1.slice(1,3), 16);
            const g1 = parseInt(c1.slice(3,5), 16);
            const b1 = parseInt(c1.slice(5,7), 16);
            const r2 = parseInt(c2.slice(1,3), 16);
            const g2 = parseInt(c2.slice(3,5), 16);
            const b2 = parseInt(c2.slice(5,7), 16);
            const r = Math.round(r1 + (r2 - r1) * f);
            const g = Math.round(g1 + (g2 - g1) * f);
            const b = Math.round(b1 + (b2 - b1) * f);
            return `rgb(${r},${g},${b})`;
        }

        function getColor(h, isWater, ambient) {
            let r, g, b;

            if (isWater) {
                const depth = (waterLevel - h) / waterLevel;
                r = 30 + depth * 20;
                g = 80 + depth * 30;
                b = 150 + depth * 50;
            } else {
                const normalized = (h - waterLevel) / (1 - waterLevel);

                if (normalized < 0.2) {
                    // Beach/sand
                    r = 194 + normalized * 50;
                    g = 178 + normalized * 30;
                    b = 128;
                } else if (normalized < 0.5) {
                    // Grass
                    r = 50 + normalized * 40;
                    g = 120 + normalized * 60;
                    b = 50;
                } else if (normalized < 0.75) {
                    // Rock
                    const gray = 100 + (normalized - 0.5) * 100;
                    r = gray;
                    g = gray - 10;
                    b = gray - 20;
                } else {
                    // Snow
                    const white = 200 + (normalized - 0.75) * 200;
                    r = g = b = white;
                }
            }

            // Apply ambient lighting
            r = Math.floor(r * ambient);
            g = Math.floor(g * ambient);
            b = Math.floor(b * ambient);

            return `rgb(${r},${g},${b})`;
        }

        function screenToGrid(sx, sy) {
            // Convert screen coordinates to grid coordinates
            const offsetX = width / 2;
            const offsetY = height / 3;
            const tw = TILE_WIDTH * zoom;
            const th = TILE_HEIGHT * zoom;

            // Adjust for rotation
            const cos = Math.cos(rotation);
            const sin = Math.sin(rotation);

            // This is an approximation - find closest tile
            let bestDist = Infinity;
            let bestTile = null;

            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const h = terrainData[y][x];
                    const isWater = h < waterLevel;
                    const elevation = (isWater ? waterLevel * heightScale : h * heightScale) * zoom;

                    // Rotated grid position
                    const gx = x - GRID_SIZE / 2;
                    const gy = y - GRID_SIZE / 2;
                    const rx = gx * cos - gy * sin;
                    const ry = gx * sin + gy * cos;

                    const isoX = (rx - ry) * tw + offsetX;
                    const isoY = (rx + ry) * th / 2 + offsetY - elevation;

                    const dist = Math.sqrt((sx - isoX) ** 2 + (sy - isoY) ** 2);
                    if (dist < bestDist) {
                        bestDist = dist;
                        bestTile = { x, y };
                    }
                }
            }

            return bestTile;
        }

        function sculptTerrain(gx, gy, mode) {
            const strength = 0.02;

            for (let dy = -brushSize; dy <= brushSize; dy++) {
                for (let dx = -brushSize; dx <= brushSize; dx++) {
                    const tx = gx + dx;
                    const ty = gy + dy;
                    if (tx < 0 || tx >= GRID_SIZE || ty < 0 || ty >= GRID_SIZE) continue;

                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > brushSize) continue;

                    const falloff = 1 - (dist / brushSize);

                    if (mode === 'raise') {
                        terrainData[ty][tx] = Math.min(1, terrainData[ty][tx] + strength * falloff);
                    } else if (mode === 'lower') {
                        terrainData[ty][tx] = Math.max(0, terrainData[ty][tx] - strength * falloff);
                    } else if (mode === 'flatten') {
                        const target = 0.5;
                        terrainData[ty][tx] += (target - terrainData[ty][tx]) * 0.1 * falloff;
                    }
                }
            }
        }

        function render() {
            const { sky, ambient } = getSkyColor();
            ctx.fillStyle = sky;
            ctx.fillRect(0, 0, width, height);

            // Smooth rotation
            rotation += (targetRotation - rotation) * 0.1;

            const offsetX = width / 2;
            const offsetY = height / 3;
            const tw = TILE_WIDTH * zoom;
            const th = TILE_HEIGHT * zoom;
            const cos = Math.cos(rotation);
            const sin = Math.sin(rotation);

            // Collect and sort tiles for proper render order
            const tiles = [];

            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const h = terrainData[y][x];

                    // Rotated grid position
                    const gx = x - GRID_SIZE / 2;
                    const gy = y - GRID_SIZE / 2;
                    const rx = gx * cos - gy * sin;
                    const ry = gx * sin + gy * cos;

                    tiles.push({ x, y, h, rx, ry });
                }
            }

            // Sort by depth (ry then rx for isometric)
            tiles.sort((a, b) => (a.ry + a.rx) - (b.ry + b.rx));

            for (const tile of tiles) {
                const { x, y, h, rx, ry } = tile;

                const isoX = (rx - ry) * tw + offsetX;
                const isoY = (rx + ry) * th / 2 + offsetY;

                const isWater = h < waterLevel;
                const elevation = (isWater ? waterLevel * heightScale : h * heightScale) * zoom;
                const waterAnim = isWater ? Math.sin(time + x * 0.5 + y * 0.5) * 2 * zoom : 0;

                // Top face
                ctx.fillStyle = getColor(h, isWater, ambient);
                ctx.beginPath();
                ctx.moveTo(isoX, isoY - elevation + waterAnim);
                ctx.lineTo(isoX + tw, isoY + th / 2 - elevation + waterAnim);
                ctx.lineTo(isoX, isoY + th - elevation + waterAnim);
                ctx.lineTo(isoX - tw, isoY + th / 2 - elevation + waterAnim);
                ctx.closePath();
                ctx.fill();

                // Side faces (only for land)
                if (!isWater) {
                    // Left face
                    ctx.fillStyle = `rgba(0,0,0,${0.3 * ambient})`;
                    ctx.beginPath();
                    ctx.moveTo(isoX - tw, isoY + th / 2 - elevation);
                    ctx.lineTo(isoX, isoY + th - elevation);
                    ctx.lineTo(isoX, isoY + th);
                    ctx.lineTo(isoX - tw, isoY + th / 2);
                    ctx.closePath();
                    ctx.fill();

                    // Right face
                    ctx.fillStyle = `rgba(0,0,0,${0.4 * ambient})`;
                    ctx.beginPath();
                    ctx.moveTo(isoX, isoY + th - elevation);
                    ctx.lineTo(isoX + tw, isoY + th / 2 - elevation);
                    ctx.lineTo(isoX + tw, isoY + th / 2);
                    ctx.lineTo(isoX, isoY + th);
                    ctx.closePath();
                    ctx.fill();
                }
            }

            // Draw sun/moon indicator
            const sunAngle = (timeOfDay / 24) * Math.PI * 2 - Math.PI / 2;
            const sunX = width - 60 + Math.cos(sunAngle) * 30;
            const sunY = 60 + Math.sin(sunAngle) * 30;

            if (timeOfDay > 6 && timeOfDay < 20) {
                // Sun
                ctx.fillStyle = '#ffdd00';
                ctx.beginPath();
                ctx.arc(sunX, sunY, 8, 0, Math.PI * 2);
                ctx.fill();
            } else {
                // Moon
                ctx.fillStyle = '#ddd';
                ctx.beginPath();
                ctx.arc(sunX, sunY, 6, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function animate() {
            time += 0.05;
            render();
            requestAnimationFrame(animate);
        }

        // Event listeners
        canvas.addEventListener('mousedown', e => {
            if (e.button === 0) {
                const tile = screenToGrid(e.clientX, e.clientY);
                if (tile) {
                    isSculpting = true;
                    const mode = e.shiftKey ? 'lower' : sculptMode;
                    sculptTerrain(tile.x, tile.y, mode);
                }
            }
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        canvas.addEventListener('mousemove', e => {
            if (isSculpting) {
                const tile = screenToGrid(e.clientX, e.clientY);
                if (tile) {
                    const mode = e.shiftKey ? 'lower' : sculptMode;
                    sculptTerrain(tile.x, tile.y, mode);
                }
            } else if (isDragging) {
                const dx = e.clientX - lastMouseX;
                targetRotation += dx * 0.005;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            isSculpting = false;
        });

        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
            isSculpting = false;
        });

        canvas.addEventListener('wheel', e => {
            e.preventDefault();
            zoom *= e.deltaY > 0 ? 0.95 : 1.05;
            zoom = Math.max(0.5, Math.min(3, zoom));
        });

        document.getElementById('height').addEventListener('input', e => {
            heightScale = parseInt(e.target.value);
            document.getElementById('heightLabel').textContent = heightScale;
        });

        document.getElementById('water').addEventListener('input', e => {
            waterLevel = parseFloat(e.target.value);
            document.getElementById('waterLabel').textContent = waterLevel.toFixed(2);
        });

        document.getElementById('timeOfDay').addEventListener('input', e => {
            timeOfDay = parseFloat(e.target.value);
            const hours = Math.floor(timeOfDay);
            const mins = Math.floor((timeOfDay % 1) * 60);
            document.getElementById('timeLabel').textContent =
                `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;
        });

        document.getElementById('brush').addEventListener('input', e => {
            brushSize = parseInt(e.target.value);
            document.getElementById('brushLabel').textContent = brushSize;
        });

        document.getElementById('raise').addEventListener('click', e => {
            sculptMode = 'raise';
            document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
            e.target.classList.add('active');
        });

        document.getElementById('lower').addEventListener('click', e => {
            sculptMode = 'lower';
            document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
            e.target.classList.add('active');
        });

        document.getElementById('flatten').addEventListener('click', e => {
            sculptMode = 'flatten';
            document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
            e.target.classList.add('active');
        });

        document.getElementById('regenerate').addEventListener('click', () => {
            seed = Math.random() * 10000;
            generateTerrain();
        });

        window.addEventListener('resize', resize);
        resize();
        generateTerrain();
        animate();
    </script>
</body>
</html>
